var installPromiseMatchers;(function(){var t;installPromiseMatchers=function(){angular.mock.inject(function($injector){t=$injector.get("$rootScope")})};var e={PENDING:"pending",REJECTED:"rejected",RESOLVED:"resolved"},a=function(a,n,c,o,r){var u={};if(a.then(function(t){u.actualData=t,u.actualState=e.RESOLVED},function(t){u.actualData=t,u.actualState=e.REJECTED}),t.$apply(),u.message="Expected "+u.actualState+" to be "+n,u.pass=u.actualState===n,void 0!==c&&u.pass){u.pass=o?c&&c.asymmetricMatch?o.equals(u.actualData,c,r):angular.equals(u.actualData,c):c instanceof jasmine.Matchers.Any||c instanceof jasmine.Matchers.ObjectContaining?c.jasmineMatches(u.actualData):angular.equals(u.actualData,c);var s="object"==typeof u.actualData?JSON.stringify(u.actualData):u.actualData,i="object"==typeof c?JSON.stringify(c):c;u.message="Expected "+s+" to be "+i}return u},n=function(t){return{message:"Expected "+t+" to be a Promise",pass:t&&t.then instanceof Function}},c={toBePromise:function(){return n(this.actual)},toBeRejected:function(){return a(this.actual,e.REJECTED).pass},toBeRejectedWith:function(t){return a(this.actual,e.REJECTED,t).pass},toBeResolved:function(){return a(this.actual,e.RESOLVED).pass},toBeResolvedWith:function(t){return a(this.actual,e.RESOLVED,t).pass}},o={toBePromise:function(){return{compare:function(t){return n(t)}}},toBeRejected:function(){return{compare:function(t){return a(t,e.REJECTED)}}},toBeRejectedWith:function(t,n){return{compare:function(c,o){return a(c,e.REJECTED,o,t,n)}}},toBeResolved:function(){return{compare:function(t){return a(t,e.RESOLVED)}}},toBeResolvedWith:function(t,n){return{compare:function(c,o){return a(c,e.RESOLVED,o,t,n)}}}},r=/^2/.test(jasmine.version);beforeEach(function(){r?jasmine.addMatchers(o):this.addMatchers(c)})})();